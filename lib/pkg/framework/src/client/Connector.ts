/* tslint:disable no-namespace no-empty-interface max-classes-per-file */
import EntityBase from './EntityBase';
import superagent from 'superagent';

class Service extends EntityBase.ServiceDefault {
  public handleWebhookEvent = async (ctx: EntityBase.Types.Context) => {
    const webhookAuthId = this.getEventAuthId(ctx);
    const isChallenge = this.initializationChallenge(ctx);

    if (!webhookAuthId && !isChallenge) {
      ctx.throw(400, `webhooks not implemented for connector ${ctx.state.params.entityId}`);
    }

    const isValid = this.validateWebhookEvent(ctx);
    if (!isValid) {
      ctx.throw(400, `webhook event failed validation for connector ${ctx.state.params.entityId}`);
    }

    if (isChallenge) {
      ctx.status = 200;
      return;
    }

    if (typeof webhookAuthId === 'string') {
      // Process with no await.  Happily happens in background ensuring a quick response to
      // the webhook caller.
      return this.createWebhookResponse(ctx, this.processWebhook(ctx, ctx.req.body, webhookAuthId));
    }

    // Event contains many different authId-associated entries - process them independently.
    return this.createWebhookResponse(
      ctx,
      Promise.all(
        Object.entries(webhookAuthId as Record<string, any>).map(([authId, events]: [string, any]) =>
          this.processWebhook(ctx, events, authId)
        )
      )
    );
  };

  public processWebhook = async (
    ctx: Connector.Types.Context,
    event: any,
    webhookAuthId: string
  ): Promise<superagent.Response | void> => {
    try {
      const webhookEventId = this.getWebhookLookupId(ctx, webhookAuthId);
      const webhookEventType = this.getWebhookEventType(ctx);

      // This await is necessary to guarantee that exceptions generated by superagent (for
      // networking glitches, for example) never leave the scope of this function, as this code
      // often runs without an associated try/await/catch block.
      const response = await superagent
        .post(
          `${ctx.state.params.baseUrl}/fan_out/event/webhook/${
            ctx.state.params.entityId
          }/${webhookEventType}?tag=${encodeURIComponent(webhookEventId)}`
        )
        .set('Authorization', `Bearer ${ctx.state.params.functionAccessToken}`)
        .send({
          data: event,
          connectorId: ctx.state.params.entityId,
          webhookEventId,
          webhookAuthId,
        })
        .ok((res) => true);
      return response;
    } catch (e) {
      console.log(`Error processing event:`);
      console.log(e);
    }
  };

  // Convert a webhook event into the key attached to instances by getWebhookTokenId
  public getWebhookLookupId(ctx: Connector.Types.Context, authId: string): string {
    const connectorId = ctx.state.params.entityId;
    return ['webhook', connectorId, authId].join('/');
  }

  // Convert an OAuth token into the key used to look up matching instances for a webhook.
  public getWebhookTokenId = async (ctx: Connector.Types.Context, token: any): Promise<string> => {
    const authId = await this.getTokenAuthId(ctx, token);
    const connectorId = ctx.state.params.entityId;
    return ['webhook', connectorId, authId].join('/');
  };

  // Setters allow for individual Connectors to easily apply unique values if need be

  // initializationChallenge returns true if the event is a security challenge by the remote service, and not
  // an actual event to be sent onwards to an integration.
  public setInitializationChallenge = (handler: (ctx: Connector.Types.Context) => boolean) => {
    this.initializationChallenge = handler;
  };

  // getEventAuthId takes an external event and extracts the authId
  public setGetEventAuthId = (handler: (ctx: Connector.Types.Context) => Record<string, any> | string | void): void => {
    this.getEventAuthId = handler;
  };

  // getTokenAuthId takes an authentication token and extracts out the authId, to match against future
  // events.
  public setGetTokenAuthId = (handler: (ctx: Connector.Types.Context, token: any) => Promise<string | void>): void => {
    this.getTokenAuthId = handler;
  };

  // createWebhookResponse sets any necessary response elements that the service expects in the webhook
  // response, while the webhook is being processed in the other promise.
  public setCreateWebhookResponse = (
    handler: (ctx: Connector.Types.Context, processPromise?: Promise<any>) => Promise<void>
  ) => {
    this.createWebhookResponse = handler;
  };

  // validateWebhookEvent validates the integrity of the event, usually via some cryptographic hash.
  public setValidateWebhookEvent = (handler: (ctx: Connector.Types.Context) => boolean) => {
    this.validateWebhookEvent = handler;
  };

  // getWebhookEventType returns a string that can becomes part of the event path, and is used to filter for
  // different webhooks in the integration.
  public setGetWebhookEventType = (handler: (ctx: Connector.Types.Context) => string) => {
    this.getWebhookEventType = handler;
  };

  // Default configuration functions
  private getEventAuthId = (ctx: Connector.Types.Context): Record<string, any> | string | void => {
    ctx.throw(500, 'Event AuthId configuration missing.  Required for webhook processing.');
  };

  private getTokenAuthId = async (ctx: Connector.Types.Context, token: any): Promise<string | void> => {
    // No throw here.  This is called in the auth flow and needs to continue regardless of success
  };

  private createWebhookResponse = async (
    ctx: Connector.Types.Context,
    processPromise?: Promise<any>
  ): Promise<void> => {
    // No special response generated by default
  };

  private validateWebhookEvent = (ctx: Connector.Types.Context): boolean => {
    ctx.throw(500, 'Webhook Validation configuration missing. Required for webhook processing.');
  };

  private getWebhookEventType = (ctx: Connector.Types.Context): string => {
    return `${ctx.state.params.entityId}`;
  };

  private initializationChallenge = (ctx: Connector.Types.Context): boolean => {
    ctx.throw(500, 'Webhook Challenge configuration missing. Required for webhook processing.');
  };
}

class Connector extends EntityBase {
  constructor() {
    super();
    this.router.post('/api/fusebit_webhook_event', async (ctx: Connector.Types.Context) => {
      await this.service.handleWebhookEvent(ctx);
    });
  }
  public service = new Service();
  public middleware = new EntityBase.MiddlewareDefault();
  public storage = new EntityBase.StorageDefault();
  public response = new EntityBase.ResponseDefault();
}
namespace Connector {
  export namespace Types {
    export type Context = EntityBase.Types.Context;
    export type Next = EntityBase.Types.Next;
    export interface IOnStartup extends EntityBase.Types.IOnStartup {}
    export type WebhookEventPayload = {
      event: string; // event name
      parameters: {
        connectorId: string;
        instanceIds: string[];
        webhookEventId: string;
        event: any;
        webhookAuthId: string;
      };
    };
  }
}
export default Connector;
